# Homework 02
setwd("~/WORKING_DIRECTORIES/biostat.696/homework02")
library(readr)
library(ggplot2)
library(ggmap)
library(maps)
library(mapdata)
library(akima)
library(fields)
library(dplyr)
library(broom)
library(gstat)
library(geoR)

data <- read_table2("BatonRouge.txt")
colnames(data) <- c("logSP", "AreaL", "AreaO", "Age",
                    "Bed", "Bath", "HBath", "Lat",
                    "Lon", "East", "North")
data$EastKM <- data$East/1000
data$NorthKM <- data$North/1000

# Plot the sampled sites with the corresponding observed 
# log-selling prices
ggplot() +
  geom_point(data = data,
             aes(x=EastKM, y = NorthKM, color = logSP)) +
  ggtitle("Log Selling Price of Homes in Baton Rouge, LA") +
  theme(plot.title = element_text(hjust = 0.5)) +
  xlab("Easting (km)") +
  ylab("Northing (km)") +
  scale_color_gradient(name = "Log Selling Price")

# Fit an ordinary least squares regression
data50 <- data[1:50,]
mod01 <- lm(data = data50,
            logSP ~ AreaL + Age + AreaO + Bath)
summary(mod01)
data50$res <- resid(mod01)

# Obtain empirical semi-variogram of the residuals
emp_var <- variogram(res~1, locations =~ East+North, data50, width = 500, cutoff = 5000)
emp_var
plot(emp_var,col="black",type="p",pch=20, main = "Empirical Variogram")

# Fit exponential semi-variogram
exp_var <- fit.variogram(emp_var,vgm(psill=0.02,"Exp",range=120,nugget=0.005),fit.method=2)
exp_var
plot(emp_var, exp_var, main = "Exponential Semi-Variogram")

sigma2.exp <- exp_var$psill[2]
phi.exp <- exp_var$range[2]
tau2.exp <- exp_var$psill[1]

data.geo <- as.geodata(data50[,c(1,12,13)],coords.col=c(2,3),data.col=1)

reml.exp <- likfit(data.geo, trend = ~data50$AreaL+data50$AreaO+data50$Age+data50$Bath, 
                         ini=c(sigma2.exp, phi.exp), nugget=tau2.exp, fix.nug = FALSE, lik.met="REML")
reml.exp
sigma2.reml <- reml.exp$sigmasq
phi.reml <- reml.exp$phi
tau2.reml <- reml.exp$tausq

data20 <- data[c(52:71),]

hw.control <- krige.control(type.krige="ok",trend.d="1st",trend.l="1st",cov.model = "exponential",
                               cov.pars=c(sigma2.reml,phi.reml),nugget=tau2.reml)

loc.hw <- matrix(c(data20$EastKM,data20$NorthKM),nrow=20,ncol=2)
hw.pred <- krige.conv(data.geo,locations=loc.hw,krige=hw.control)
hw.pred$predict

# RMSE
sqrt(sum((hw.pred$predict-data20$logSP)^2)/20)

# MASE
sum((hw.pred$predict-data20$logSP)^2)/20

# Average of Prediction Variances
sum(hw.pred$krige.var)/20

# Confidence Interval Limits
lower <- hw.pred$predict - 1.645*sqrt(hw.pred$krige.var)
upper <- hw.pred$predict + 1.645*sqrt(hw.pred$krige.var)

contained <- 1*(data20$logSP >= lower)&(data20$logSP <= upper)


library(spBayes)
#
coords <- as.matrix(cbind(data50$EastKM, data50$NorthKM),nrow=length(data50$EastKM),ncol=2)
beta.ini <- rep(10.2816,0.0005,0,-0.0057,0.0978)
sigma2.ini <- sigma2.reml
tau2.ini <- tau2.reml + 0.0001
phi.ini <- 1/phi.reml

# This fits the model
model.1 <- spLM(data50$logSP~data50$AreaL+data50$AreaO+data50$Age+data50$Bath, 
                coords=coords,starting=list("phi"=phi.ini,"sigma.sq"=sigma2.ini, "tau.sq"=tau2.ini,"beta"=beta.ini),
                tuning=list("phi"=0.001, "sigma.sq"=0.75, "tau.sq"=0.01),
                priors=list("phi.Unif"=c(0.0001, .1), "sigma.sq.IG"=c(2, 0.06),
                            "tau.sq.IG"=c(2, 0.001),"beta.Flat"), cov.model="exponential",
                n.samples=50000, verbose=TRUE, n.report=100)

# To see the output generated by the function spLM, we can use
names(model.1)
model.1$p.theta.samples[1:5,]

# This produces traces plots and plots of the posterior marginal distribution of the covariance parameters
par(mai=rep(0.4,4))
plot(model.1$p.theta.samples[,1:3])

n.samples <- 50000
burn.in <- 0.5*n.samples
model.1.other.pars <- spRecover(model.1, start=burn.in, verbose=FALSE)

# This produces traces plots and plots of the posterior marginal distribution of the beta coefficients
dim(model.1.other.pars$p.beta.recover.samples)

par(mai=rep(0.4,4),mfrow=c(2,2))
plot(model.1.other.pars$p.beta.recover.samples[,1:4])

par(mai=rep(0.4,4))
plot(model.1.other.pars$p.beta.recover.samples[,5])

par(mai=rep(0.4,4),mfrow=c(2,2))
plot(model.1.other.pars$p.theta.samples[,1:3])

# To obtain estimates and 95% credible of the covariance parameters
round(summary(model.1.other.pars$p.theta.samples)$quantiles[,c(1,3,5)],4)
round(summary(model.1.other.pars$p.theta.samples)$statistics[,c(1,2)],4)

# To obtain estimates and 95% credible of the beta coefficients
round(summary(model.1.other.pars$p.beta.recover.samples)$quantiles[,c(1,3,5)],4)
round(summary(model.1.other.pars$p.beta.recover.samples)$statistics[,c(1,2)],4)

# Making predictions (g)
data20.predcov <- matrix(cbind(rep(1,nrow(data20)),data20$AreaL,data20$AreaO,data20$Age,data20$Bath),nrow=nrow(data20),ncol=5)
pred.coords <- cbind(data20$EastKM, data20$NorthKM)
pred <- spPredict(model.1, pred.coords=pred.coords, pred.covars=data20.predcov, start=burn.in, thin=2)
names(pred)

dim(pred$p.y.predictive.samples)

## Here we compute the posterior mean of the predictions. 
post.pred.mean <- rowMeans(pred$p.y.predictive.samples)
post.pred.mean[1:20]

## Here we compute the 95% posterior predictive intervals at the 237 sites
post.pred.95ci <- apply(pred$p.y.predictive.samples,1,quantile,c(0.05,0.95))
post.pred.95ci[,1:20]

contained.pred <- 1*(data20$logSP >= post.pred.95ci[1,])&(data20$logSP <= post.pred.95ci[2,])


# Problem 2
nyleuk <- read_table2("NY_Leukemia.txt")
colnames(nyleuk) <- c("FIPS","easting","northing","pop","cases","homeowners","over65","Avg.inv.dist.TCEs","Inv.dist.nearest.TCE")

# Plot
ggplot() +
  geom_point(data = nyleuk,
             aes(x=easting, y = northing, color = cases, size = pop)) +
  ggtitle("Leukemia Cases in NY") +
  theme(plot.title = element_text(hjust = 0.5)) +
  xlab("Easting (km)") +
  ylab("Northing (km)") +
  scale_color_gradient(name = "Number of Cases")

# Fit Poisson Log-Linear Model
mod02 <- glm(data = nyleuk,
             cases ~ homeowners+over65+Avg.inv.dist.TCEs,
             family = "poisson")
summary(mod02)


nyleuk$cases[nyleuk$cases == 0] <- nyleuk$cases[nyleuk$cases == 0] + 0.5
nyleuk$logcases <- log(nyleuk$cases)

mod03 <- lm(data = nyleuk,
            logcases ~ homeowners+over65+Avg.inv.dist.TCEs)
summary(mod03)
nyleuk$res <- resid(mod03)

# Obtain empirical semi-variogram of the residuals
emp_var2 <- variogram(res~1, locations =~ easting+northing, nyleuk, boundaries = c(15,seq(from=20,to=110,by=10)))
emp_var2
plot(emp_var2,col="black",type="p",pch=20, main = "Empirical Variogram")

# Fit exponential semi-variogram
exp_var2 <- fit.variogram(emp_var2,vgm(psill=0.65,"Exp",range=5,nugget=0.6),fit.method=2)
exp_var2
plot(emp_var2, exp_var2, main = "Exponential Semi-Variogram")

sigma2.exp2 <- exp_var2$psill[2]
phi.exp2 <- exp_var2$range[2]
tau2.exp2 <- exp_var2$psill[1]

# Fit a Poisson spatial linear mixed model
beta.starting <- coefficients(mod02)
beta.tuning <- 1.3*t(chol(vcov(mod02)))
phi.starting <- 1/phi.exp2
sigma.starting <- sigma2.exp2
tau.starting <- tau2.exp2

n.samples <- 10000
coords <- as.matrix(cbind(nyleuk$easting, nyleuk$northing),nrow=length(nyleuk$easting),ncol=2)

spatial.logist <- spGLM(nyleuk$cases ~ nyleuk$homeowners+nyleuk$over65+nyleuk$Avg.inv.dist.TCEs, family="poisson", coords=coords,
                        starting=list("beta"=beta.starting, "phi"=phi.starting,"sigma.sq"=sigma.starting,"tau.sq"=tau.starting,
                                      "w"=0),
                        tuning=list("beta"=beta.tuning, "phi"=0.005, "sigma.sq"=0.005, "tau.sq"=0.01, "w"=0),
                        priors=list("beta.Normal"=list(rep(0,4),rep(100,4)), "phi.Unif"=c(0.001,1), "sigma.sq.IG"=c(2, 1),
                                    "tau.sq.IG"=c(2, 0.001)),
                        n.samples=n.samples, cov.model="exponential", verbose=TRUE, n.report=100)

# Trace plots of the parameters
par(mai=rep(0.5,4))
plot(spatial.logist$p.beta.theta.samples)


## Here we take the burn-in to be 90% of the iterations
burn.in <- 0.5*n.samples
sub.samps <- burn.in:n.samples

## Here we calculate the summary statistics for the samples of the
## covariance parameters after the burn-in
print(summary(window(spatial.logist$p.beta.theta.samples, start=burn.in)))

## Here we derive the probability of having malaria.
## For this we take the beta samples, the samples for the spatial random effects and
## we apply the formula to compute the predicted probability in a logistic regression
beta.hat <- spatial.logist$p.beta.theta.samples[sub.samps,1:3]
eta.hat <- spatial.logist$p.w.samples[,sub.samps]
p.hat <- matrix(0,dim(un.coord)[1],dim(beta.hat)[1])
for(k in 1:dim(beta.hat)[1]){
  p.hat[,k] <- exp(beta.hat[k,1]+beta.hat[k,2]*net.use.coord.gambia+beta.hat[k,3]*green.coord.gambia+eta.hat[,k])/(1+exp(beta.hat[k,1]+beta.hat[k,2]*net.use.coord.gambia+beta.hat[k,3]*green.coord.gambia+eta.hat[,k]))
}

## This is the estimated probability of malaria (at each location, we are taking the median
## of the predicted probability)
p.hat.median <- apply(p.hat,1,median)


## Here we estimate the spatial random effects and we compute the median, and the extremes of a 95% confidence interval
eta.post.median <- apply(eta.hat,1,median)
eta.post.low.bd <- apply(eta.hat,1,quantile,0.025)
eta.post.upp.bd <- apply(eta.hat,1,quantile,0.975)

## This is to make a plot of the estimated spatial random effects
surf.eta <- mba.surf(cbind(un.coord,eta.post.median),no.X=100, no.Y=100, extend=TRUE)$xyz.est
image.plot(surf.eta, main="Interpolated posterior median \n of spatial random effects")
contour(surf.eta, add=TRUE)
points(un.coord[,1], un.coord[,2],pch=19,col="black")

## This is to make a plot of the lower bound of the 95% CI the estimated spatial random effects
surf.eta.low <- mba.surf(cbind(un.coord,eta.post.low.bd),no.X=100, no.Y=100, extend=TRUE)$xyz.est
image.plot(surf.eta.low, main="Interpolated lower bound of  \n 95% CI for spatial random effects",zlim=c(-3,4))
contour(surf.eta.low, add=TRUE)
points(un.coord[,1], un.coord[,2],pch=19,col="black")

surf.eta.upp <- mba.surf(cbind(un.coord,eta.post.upp.bd),no.X=100, no.Y=100, extend=TRUE)$xyz.est
image.plot(surf.eta.upp, main="Interpolated upper bound of \n of 95% CI for spatial random effects",zlim=c(-3,4))
contour(surf.eta.upp, add=TRUE)
points(un.coord[,1], un.coord[,2],pch=19,col="black")


## This is to make a plot of the estimated probability of malaria
surf.p <- mba.surf(cbind(un.coord,p.hat.median),no.X=100, no.Y=100, extend=TRUE)$xyz.est
image.plot(surf.p, main="Interpolated posterior median of \n probability of malaria",col=heat.colors(100)[90:1])
contour(surf.p, add=TRUE)
points(un.coord[,1], un.coord[,2],pch=19,col="black")